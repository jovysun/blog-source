---
title: 数据结构与算法@复杂度分析
permalink: 数据结构与算法@复杂度分析
tags:
  - JavaScript
categories:
  - 基础
  - 数据结构与算法
date: 2019-05-18 23:17:45
updated: 2019-05-18 23:17:45
---

# 概述

复杂度分析是学习算法的非常重要的部分，主要分为时间复杂度分析和空间复杂度分析。掌握大“O”表示法及几种常见时间复杂度实例分析。知道最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度和均摊时间复杂度。

<!-- more -->

# 详述

## 大 O 时间复杂度表示法

```js
function cal(n) {
  var sum = 0;
  var i = 1;
  var j = 1;
  for (; i <= n; ++i) {
    j = 1;
    for (; j <= n; ++j) {
      sum = sum + i * j;
    }
  }
}
```

假如每个语句的执行时间是 unit_time，那么这段代码的总执行时间 T(n)是多少呢？

<p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n<sup>2</sup>遍，所以需要 2n<sup>2</sup> * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n<sup>2</sup>+2n+3)*unit_time。</p>

<p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p>

总结成一个公式如下：
![](o.png)

<p>所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n<sup>2</sup>+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>

<p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n<sup>2</sup>)。</p>

## 时间复杂度分析

1. 只关注循环执行次数最多的一段代码

```js
function cal(n) {
  var sum = 0;
  var i = 1;
  for (; i <= n; ++i) {
    sum = sum + 1;
  }
  return sum;
}
```

以上代码总的时间复杂度就是 O(n)。

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

```js
function cal(n) {
  var sum_1 = 0;
  var p = 1;
  for (; p < 100; ++p) {
    sum_1 = sum_1 + p;
  }

  var sum_2 = 0;
  var q = 1;
  for (; q < n; ++q) {
    sum_2 = sum_2 + q;
  }

  var sum_3 = 0;
  var i = 1;
  var j = 1;
  for (; i <= n; ++i) {
    j = 1;
    for (; j <= n; ++j) {
      sum_3 = sum_3 + i * j;
    }
  }

  return sum_1 + sum_2 + sum_3;
}
```

<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n<sup>2</sup>)。也就是说：<strong>总的时间复杂度<strong><strong>就</strong></strong>等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：</p>

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```js
function cal(n) {
  var ret = 0;
  var i = 1;
  for (; i < n; ++i) {
    ret = ret + f(i);
  }
}

function f(n) {
  var sum = 0;
  var i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

<p>我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n<sup>2</sup>)。</p>

## 几种常见时间复杂度实例分析

![](normal.jpg)

1. O(1)
   O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。

```js
var i = 8;
var j = 6;
var sum = i + j;
```

<p>总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，<strong>一般<strong><strong>情况下</strong></strong>，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</p>

2. O(logn)、O(nlogn)
   对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。如下代码：

```js
var i = 1;
while (i <= n) {
  i = i * 2;
}
```

一个个列出来，就是这个样子：
![](log.jpg)

<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2<sup>x</sup>=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log<sub>2</sub>n，所以，这段代码的时间复杂度就是 O(log<sub>2</sub>n)。</p>

现在稍微改下：

```js
var i = 1;
while (i <= n) {
  i = i * 3;
}
```

这段代码的时间复杂度为 O(log<sub>3</sub>n)。

<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p>

<p>我们知道，对数之间是可以互相转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 * log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C *  log<sub>2</sub>n)，其中 C=log<sub>3</sub>2 是一个常量。基于我们前面的一个理论：<strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong>。所以，O(log<sub>2</sub>n) 就等于 O(log<sub>3</sub>n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>

<p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>

3. O(m+n)、O(m\*n)

```js
function cal(m, n) {
  var sum_1 = 0;
  var i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  var sum_2 = 0;
  var j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

<p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p>

<p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。</p>

## 空间复杂度分析

<p>前面我讲过，时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>

```js
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}

```

<p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>

<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup> )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>

## 内容小结

<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup> )。<strong>复杂度分析并不难，关键在于多练。</strong></p>

另外还有四个时间复杂度知识可以进一步学习下：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。

# 参考

极客时间——数据结构与算法之美
